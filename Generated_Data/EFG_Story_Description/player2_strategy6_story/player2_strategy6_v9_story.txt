Story 1: A Floating City Civil War
This game takes place in a setting where a floating city civil war. Players engage through strategic decisions.

Player1 may choose from:
  A1: power grid seize,
  A2: wind turbine hack,
  A3: drone strike bluff,
  A4: bridge lock,
  A5: food drop reroute,
  A6: council message jam.

Player2 may counter with:
  B1: dock gate breach,
  B2: citizen revolt,
  B3: rebel fake ID,
  B4: speaker takeover,
  B5: hover patrol,
  B6: water cut trap.

Story 2: A Quantum Casino Heist
This game takes place in a setting where a quantum casino heist. Players engage through strategic decisions.

Player1 may choose from:
  A1: deck entanglement,
  A2: chip mimic loop,
  A3: card collapse scan,
  A4: dice spin interference,
  A5: AI blindspot hack,
  A6: exit phase jump.

Player2 may counter with:
  B1: randomizer fix,
  B2: cheat detector cascade,
  B3: time rewind alert,
  B4: bluff camera AI,
  B5: door trace,
  B6: roulette bug.

Story 3: An Underworld Political Smear Campaign
This game takes place in a setting where an underworld political smear campaign. Players engage through strategic decisions.

Player1 may choose from:
  A1: tabloid leak,
  A2: fake charity tie,
  A3: offshore twist,
  A4: enemy photo plant,
  A5: ex-employee interview,
  A6: staged heckler.

Player2 may counter with:
  B1: integrity doc,
  B2: voter rally,
  B3: defamation suit,
  B4: empathy pivot,
  B5: moderator ambush,
  B6: whistleblower leak.

Story 4: A Transdimensional Marketplace Barter
This game takes place in a setting where a transdimensional marketplace barter. Players engage through strategic decisions.

Player1 may choose from:
  A1: phase-warp fruit,
  A2: cloudskin weave,
  A3: telepathy mirror,
  A4: empathy gem,
  A5: anti-time plant,
  A6: sonic ink scroll.

Player2 may counter with:
  B1: currency void,
  B2: value inversion,
  B3: cultural mismatch,
  B4: memory refund,
  B5: barter illusion,
  B6: dimensional glitch.

Base Payoff Definitions:
base_payoffs = {
    "Player1": [A1=10, A2=-10, A3=10, A4=-10, A5=10, A6=-10],
    "Player2": [B1=-10, B2=10, B3=-10, B4=10, B5=-10, B6=10]
}

Adjusted Payoff Calculation:
def adjusted_payoffs(i, j):
    raw = [base_payoffs['Player1'][i], base_payoffs['Player2'][j]]
    avg = sum(raw) / 2
    return [round(p - avg, 2) for p in raw]

Example:
If Player1 selects A2 (index 1) and Player2 selects B5 (index 4):
  Player1: -10, Player2: -10
  Average = (-10 + -10) / 2 = -10.0
  Adjusted Payoffs = [Player1: 0.0, Player2: 0.0]
This ensures the outcome remains zero-sum.

